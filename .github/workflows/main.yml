name: Go report card & Test coverage

on:
  push:
    branches:
      - main
      - beta
      - dev
    tags: [ 'v*.*.*' ]

  pull_request:
    branches:
      - main
      - beta
      - dev

  workflow_dispatch:

env:
  REGISTRY_NAME: lambdatest

jobs:
  Unit_Test_Cases:
    runs-on: ubuntu-latest
    steps:
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: 1.17
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Unit Test Cases
        env:
          ENV: "dev"
        run: go test ./... -parallel 4

  Performance_Test_Cases:
    runs-on: ubuntu-latest
    steps:
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: 1.17
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Performance Test Cases
        env:
          ENV: "dev"
        run: go test ./... -parallel 4 -bench=. -benchmem

  Test_Coverage:
    runs-on: ubuntu-latest
    needs: [ Unit_Test_Cases, Performance_Test_Cases ]
    steps:
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: 1.17
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Test Code Coverage
        env:
          ENV: "dev"
        run: |
          go test -parallel 4 -coverpkg=./... -coverprofile=profile.cov ./...
          go tool cover -func profile.cov

  Go_Report_Card:
    runs-on: ubuntu-latest
    needs: [ Unit_Test_Cases, Performance_Test_Cases ]
    steps:
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: 1.17
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Run Go Report Card
        run: |
          issues_threshold=13
          gofmt_score_threshold=100
          go_vet_score_threshold=100
          gocyclo_score_threshold=91
          git clone https://github.com/gojp/goreportcard.git
          cd goreportcard
          make install
          go install ./cmd/goreportcard-cli
          cd ..
          rm -rf goreportcard
          goreportcard-cli | tee reportcard.txt
          files=$(cat reportcard.txt| grep 'Files:' | awk  '{print $2}' | tr -d \%)
          issues=$(cat reportcard.txt| grep 'Issues:' | awk  '{print $2}' | tr -d \%)
          gofmt_score=$(cat reportcard.txt| grep 'gofmt:' | awk  '{print $2}' | tr -d \%)
          go_vet_score=$(cat reportcard.txt| grep 'go_vet:' | awk  '{print $2}' | tr -d \%)
          gocyclo_score=$(cat reportcard.txt| grep 'gocyclo:' | awk  '{print $2}' | tr -d \%)
          rm reportcard.txt
          failed_checks=0
          failure_reason=""
          if [[ $issues -gt $issues_threshold ]]; then
            failure_reason="${failure_reason}\nIssues: $issues. Threshold was: $issues_threshold."
            ((failed_checks+=1))
          fi
          if [[ $gofmt_score -lt $gofmt_score_threshold ]]; then
            failure_reason="${failure_reason}\ngo-fmt score: $gofmt_score. Threshold was: $gofmt_score_threshold."
            ((failed_checks+=1))
          fi
          if [[ $go_vet_score -lt $go_vet_score_threshold ]]; then
            failure_reason="${failure_reason}\ngo-vet score: $go_vet_score. Threshold was: $go_vet_score_threshold."
            ((failed_checks+=1))
          fi
          if [[ $gocyclo_score -lt $gocyclo_score_threshold ]]; then
            failure_reason="${failure_reason}\ngo-cyclo score: $gocyclo_score. Threshold was: $gocyclo_score_threshold."
            ((failed_checks+=1))
          fi
          if [[ $failed_checks -gt 0 ]]; then
            goreportcard-cli -v
            printf "\n\n\n${failure_reason}\nFrom the above output, filter out issues in your touched files and fix them."
            exit 1
          else
            exit 0
          fi
  
  Build_To_Deploy:
    if: ${{ github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/beta' || github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    needs: [ Test_Coverage, Go_Report_Card ]
    steps:
      - name: Inject slug/short variables
        uses: rlespinasse/github-slug-action@v3.x
        
      - name: Checkout
        uses: actions/checkout@v2.4.0

      - name: Build Cloud Runners
        if: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/beta' || github.ref == 'refs/heads/dev' }}
        run: |
          curl -X  POST "https://api.github.com/repos/LambdaTest/test-at-scale-deployment/actions/workflows/main.yml/dispatches" -H "Authorization:Bearer ${{ secrets.GH_API_TOKEN }}" -d '{"ref":"${{env.GITHUB_REF_SLUG}}"}'

      - name: Setup Docker Image Tags
        run: |
          if [ ${GITHUB_REF_SLUG} == "main" ] ; then
            echo "NUCLEUS_TAGS=${REGISTRY_NAME}/nucleus:base" >> $GITHUB_ENV
            echo "SYNAPSE_TAGS=${REGISTRY_NAME}/synapse:latest","${REGISTRY_NAME}/synapse:prod" >> $GITHUB_ENV
          else
            echo "NUCLEUS_TAGS=${REGISTRY_NAME}/nucleus:base-${GITHUB_REF_SLUG}" >> $GITHUB_ENV
            echo "SYNAPSE_TAGS=${REGISTRY_NAME}/synapse:${GITHUB_REF_SLUG}" >> $GITHUB_ENV
          fi
          echo "BOTNAME=Test-at-Scale bot ${GITHUB_REF_SLUG}" >> $GITHUB_ENV

      - name: Docker Login
        uses: docker/login-action@v1.13.0
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}
          logout: true

      - name: Build and push Nucleus images
        if: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/beta' || github.ref == 'refs/heads/dev' || startsWith(github.ref, 'refs/tags/v') }}
        uses: docker/build-push-action@v2.9.0
        with:
          context: .
          tags: ${{ env.NUCLEUS_TAGS }}
          file: build/nucleus/Dockerfile
          push: true

      - name: Build and push Synapse images
        if: ${{ github.ref == 'refs/heads/beta' || github.ref == 'refs/heads/dev' ||  github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v') }}
        uses: docker/build-push-action@v2.9.0
        with:
          context: .
          tags: ${{ env.SYNAPSE_TAGS }}
          file: build/synapse/Dockerfile
          push: true

      - uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          fields: repo,message,commit,author,action,eventName,ref,workflow,job,took
          author_name: ${{ env.BOTNAME }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: always()